## Detailed Implementation Plan

Based on my analysis, here's the complete plan for splitting the `user-goals-and-preferences.ts` schema into separate tables:

### Phase 1: Database Schema (4 new files)

#### 1.1 [`packages/db/src/schema/user-goals.ts`](packages/db/src/schema/user-goals.ts)

```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, varchar, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";

export type FocusArea = "personal" | "career" | "health" | "relationships" | "finance" | "creative" | "learning";

export const userGoals = pgTable("user_goals", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .references(() => user.id)
    .notNull()
    .unique(), // 1:1 relationship

  // Core goals
  goalsText: text("goals_text").notNull().default(""),
  focusAreas: varchar("focus_areas", { length: 255 }).notNull().default("personal"),
  defaultFocusArea: varchar("default_focus_area", { length: 50 }),

  // Tracking
  inputSavedAt: timestamp("input_saved_at").notNull().defaultNow(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const userGoalsRelations = relations(userGoals, ({ one }) => ({
  user: one(user, {
    fields: [userGoals.userId],
    references: [user.id],
  }),
}));
```

#### 1.2 [`packages/db/src/schema/user-preferences.ts`](packages/db/src/schema/user-preferences.ts)

```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, varchar, integer, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";
import { complexityEnum, weekendEnum } from "./enums";

export const userPreferences = pgTable("user_preferences", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .references(() => user.id)
    .notNull()
    .unique(),

  // Task preferences
  taskComplexity: complexityEnum("task_complexity").notNull().default("Balanced"),
  weekendPreference: weekendEnum("weekend_preference").notNull().default("Mixed"),
  preferredTaskDuration: integer("preferred_task_duration").default(45),

  // Metadata
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const userPreferencesRelations = relations(userPreferences, ({ one }) => ({
  user: one(user, {
    fields: [userPreferences.userId],
    references: [user.id],
  }),
}));
```

#### 1.3 [`packages/db/src/schema/schedule-settings.ts`](packages/db/src/schema/schedule-settings.ts)

```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, jsonb, time, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";

export type FixedCommitment = {
  dayOfWeek: string;
  startTime: string;
  endTime: string;
  description: string;
};

export type FixedCommitmentsJson = {
  commitments: FixedCommitment[];
};

export const scheduleSettings = pgTable("schedule_settings", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .references(() => user.id)
    .notNull()
    .unique(),

  // Schedule configuration
  fixedCommitmentsJson: jsonb("fixed_commitments_json")
    .notNull()
    .$type<FixedCommitmentsJson>()
    .default({ commitments: [] }),
  workingHoursStart: time("working_hours_start").default("09:00").notNull(),
  workingHoursEnd: time("working_hours_end").default("17:00").notNull(),

  // Metadata
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const scheduleSettingsRelations = relations(scheduleSettings, ({ one }) => ({
  user: one(user, {
    fields: [scheduleSettings.userId],
    references: [user.id],
  }),
}));
```

#### 1.4 [`packages/db/src/schema/coach-settings.ts`](packages/db/src/schema/coach-settings.ts)

```typescript
import { relations } from "drizzle-orm";
import { pgTable, serial, text, varchar, timestamp } from "drizzle-orm/pg-core";
import { user } from "./auth";

export const COACH_TONES = ["encouraging", "direct", "analytical", "friendly"] as const;
export type CoachTone = (typeof COACH_TONES)[number];

export const coachSettings = pgTable("coach_settings", {
  id: serial("id").primaryKey(),
  userId: text("user_id")
    .references(() => user.id)
    .notNull()
    .unique(),

  // AI companion personality
  coachName: varchar("coach_name", { length: 50 }).default("Coach").notNull(),
  coachTone: varchar("coach_tone", { length: 20 })
    .$type<CoachTone>()
    .default("encouraging")
    .notNull(),

  // Metadata
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const coachSettingsRelations = relations(coachSettings, ({ one }) => ({
  user: one(user, {
    fields: [coachSettings.userId],
    references: [user.id],
  }),
}));
```

---

### Phase 2: Query Functions (4 files)

#### 2.1 Update [`packages/db/src/queries/user-goals.ts`](packages/db/src/queries/user-goals.ts)

- Change table reference from `userGoalsAndPreferences` to `userGoals`
- Keep existing functions: `getLatestGoalPreference`, `updateGoalPreference`, `upsertGoalPreference`
- Add new `createGoal` function

#### 2.2 Update [`packages/db/src/queries/user-preferences.ts`](packages/db/src/queries/user-preferences.ts)

- Change table reference from `userGoalsAndPreferences` to `userPreferences`
- Keep `getUserPreferences`, `updateUserPreferences`, `createOrUpdatePreferences`

#### 2.3 Create [`packages/db/src/queries/schedule-settings.ts`](packages/db/src/queries/schedule-settings.ts)

```typescript
import { db } from "../index";
import { eq } from "drizzle-orm";
import { scheduleSettings } from "../schema";

export async function getScheduleSettings(userId: string) {
  const [settings] = await db
    .select()
    .from(scheduleSettings)
    .where(eq(scheduleSettings.userId, userId));
  return settings;
}

export async function updateScheduleSettings(
  userId: string,
  updates: Partial<typeof scheduleSettings.$inferInsert>,
) {
  const [settings] = await db
    .update(scheduleSettings)
    .set({ ...updates, updatedAt: new Date() })
    .where(eq(scheduleSettings.userId, userId))
    .returning();
  return settings;
}

export async function upsertScheduleSettings(
  userId: string,
  data: typeof scheduleSettings.$inferInsert,
) {
  const [settings] = await db
    .insert(scheduleSettings)
    .values({ ...data, userId })
    .onConflictDoUpdate({
      target: scheduleSettings.userId,
      set: { ...data, updatedAt: new Date() },
    })
    .returning();
  return settings;
}
```

#### 2.4 Create [`packages/db/src/queries/coach-settings.ts`](packages/db/src/queries/coach-settings.ts)

```typescript
import { db } from "../index";
import { eq } from "drizzle-orm";
import { coachSettings } from "../schema";
import type { CoachTone } from "../schema/coach-settings";

export async function getCoachSettings(userId: string) {
  const [settings] = await db
    .select()
    .from(coachSettings)
    .where(eq(coachSettings.userId, userId));
  return settings;
}

export async function updateCoachSettings(
  userId: string,
  updates: { coachName?: string; coachTone?: CoachTone },
) {
  const [settings] = await db
    .update(coachSettings)
    .set({ ...updates, updatedAt: new Date() })
    .where(eq(coachSettings.userId, userId))
    .returning();
  return settings;
}

export async function upsertCoachSettings(
  userId: string,
  data: { coachName?: string; coachTone?: CoachTone },
) {
  const [settings] = await db
    .insert(coachSettings)
    .values({ userId, ...data })
    .onConflictDoUpdate({
      target: coachSettings.userId,
      set: { ...data, updatedAt: new Date() },
    })
    .returning();
  return settings;
}
```

---

### Phase 3: oRPC Routers (4 files)

#### 3.1 Create [`packages/api/src/routers/goals.ts`](packages/api/src/routers/goals.ts)

```typescript
import { z } from "zod";
import { protectedProcedure } from "../index";
import * as db from "@monthly-zen/db";

export const goalsRouter = {
  get: protectedProcedure.handler(async ({ context }) => {
    const userId = context.session.user.id;
    const goals = await db.getLatestGoalPreference(userId);
    return { success: true, data: goals };
  }),

  update: protectedProcedure
    .input(z.object({
      goalsText: z.string().optional(),
      focusAreas: z.string().optional(),
      defaultFocusArea: z.string().optional(),
    }))
    .handler(async ({ input, context }) => {
      const userId = context.session.user.id;
      const goals = await db.updateGoalPreference(userId, input);
      return { success: true, data: goals };
    }),
};
```

#### 3.2 Create [`packages/api/src/routers/preferences.ts`](packages/api/src/routers/preferences.ts) (updated)

```typescript
import { z } from "zod";
import { protectedProcedure } from "../index";
import * as db from "@monthly-zen/db";

export const preferencesRouter = {
  get: protectedProcedure.handler(async ({ context }) => {
    const userId = context.session.user.id;
    const preferences = await db.getUserPreferences(userId);
    return { success: true, data: preferences };
  }),

  update: protectedProcedure
    .input(z.object({
      taskComplexity: z.enum(["Simple", "Balanced", "Ambitious"]).optional(),
      weekendPreference: z.enum(["Work", "Rest", "Mixed"]).optional(),
      preferredTaskDuration: z.number().optional(),
    }))
    .handler(async ({ input, context }) => {
      const userId = context.session.user.id;
      const preferences = await db.updateUserPreferences(userId, input);
      return { success: true, data: preferences };
    }),
};
```

#### 3.3 Create [`packages/api/src/routers/schedule.ts`](packages/api/src/routers/schedule.ts)

```typescript
import { z } from "zod";
import { protectedProcedure } from "../index";
import * as db from "@monthly-zen/db";

export const scheduleRouter = {
  get: protectedProcedure.handler(async ({ context }) => {
    const userId = context.session.user.id;
    const settings = await db.getScheduleSettings(userId);
    return { success: true, data: settings };
  }),

  update: protectedProcedure
    .input(z.object({
      workingHoursStart: z.string().optional(),
      workingHoursEnd: z.string().optional(),
      fixedCommitmentsJson: z.any().optional(),
    }))
    .handler(async ({ input, context }) => {
      const userId = context.session.user.id;
      const settings = await db.updateScheduleSettings(userId, input);
      return { success: true, data: settings };
    }),
};
```

#### 3.4 Create [`packages/api/src/routers/coach.ts`](packages/api/src/routers/coach.ts)

```typescript
import { z } from "zod";
import { protectedProcedure } from "../index";
import * as db from "@monthly-zen/db";

export const coachRouter = {
  get: protectedProcedure.handler(async ({ context }) => {
    const userId = context.session.user.id;
    const settings = await db.getCoachSettings(userId);
    return { success: true, data: settings };
  }),

  update: protectedProcedure
    .input(z.object({
      coachName: z.string().min(1).max(50).optional(),
      coachTone: z.enum(["encouraging", "direct", "analytical", "friendly"]).optional(),
    }))
    .handler(async ({ input, context }) => {
      const userId = context.session.user.id;
      const settings = await db.updateCoachSettings(userId, input);
      return { success: true, data: settings };
    }),
};
```

#### 3.5 Update [`packages/api/src/routers/index.ts`](packages/api/src/routers/index.ts)

```typescript
// Add new imports and update appRouter
import { goalsRouter } from "./goals";
import { scheduleRouter } from "./schedule";
import { coachRouter } from "./coach";

export const appRouter = {
  // ...existing routes
  goals: goalsRouter,
  preferences: preferencesRouter,
  schedule: scheduleRouter,
  coach: coachRouter,
};
```

---

### Phase 4: Database Migrations

#### 4.1 New Tables Migration

```sql
-- Create new tables (run before data migration)
CREATE TABLE user_goals (
  id SERIAL PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES user(id) UNIQUE,
  goals_text TEXT NOT NULL DEFAULT '',
  focus_areas VARCHAR(255) NOT NULL DEFAULT 'personal',
  default_focus_area VARCHAR(50),
  input_saved_at TIMESTAMP NOT NULL DEFAULT NOW(),
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE user_preferences (
  id SERIAL PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES user(id) UNIQUE,
  task_complexity complexity NOT NULL DEFAULT 'Balanced',
  weekend_preference weekend_preference NOT NULL DEFAULT 'Mixed',
  preferred_task_duration INTEGER DEFAULT 45,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE schedule_settings (
  id SERIAL PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES user(id) UNIQUE,
  fixed_commitments_json JSONB NOT NULL DEFAULT '{"commitments": []}',
  working_hours_start TIME DEFAULT '09:00' NOT NULL,
  working_hours_end TIME DEFAULT '17:00' NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE coach_settings (
  id SERIAL PRIMARY KEY,
  user_id TEXT NOT NULL REFERENCES user(id) UNIQUE,
  coach_name VARCHAR(50) DEFAULT 'Coach' NOT NULL,
  coach_tone VARCHAR(20) DEFAULT 'encouraging' NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```

#### 4.2 Data Migration Script

```typescript
// One-time migration to copy data from old table to new tables
import { db } from "../index";
import { userGoalsAndPreferences, userGoals, userPreferences, scheduleSettings, coachSettings } from "../schema";

async function migrateData() {
  const oldRecords = await db.select().from(userGoalsAndPreferences);

  for (const record of oldRecords) {
    // Insert into user_goals
    await db.insert(userGoals).values({
      userId: record.userId,
      goalsText: record.goalsText,
      focusAreas: record.focusAreas,
      defaultFocusArea: record.defaultFocusArea,
      inputSavedAt: record.inputSavedAt,
      createdAt: record.createdAt,
      updatedAt: record.updatedAt,
    });

    // Insert into user_preferences
    await db.insert(userPreferences).values({
      userId: record.userId,
      taskComplexity: record.taskComplexity,
      weekendPreference: record.weekendPreference,
      preferredTaskDuration: record.preferredTaskDuration,
      createdAt: record.createdAt,
      updatedAt: record.updatedAt,
    });

    // Insert into schedule_settings
    await db.insert(scheduleSettings).values({
      userId: record.userId,
      fixedCommitmentsJson: record.fixedCommitmentsJson,
      workingHoursStart: record.workingHoursStart,
      workingHoursEnd: record.workingHoursEnd,
      createdAt: record.createdAt,
      updatedAt: record.updatedAt,
    });

    // Insert into coach_settings
    await db.insert(coachSettings).values({
      userId: record.userId,
      coachName: record.coachName,
      coachTone: record.coachTone,
      createdAt: record.createdAt,
      updatedAt: record.updatedAt,
    });
  }

  console.log(`Migrated ${oldRecords.length} records`);
}
```

---

### Phase 5: Frontend Updates

#### 5.1 Frontend Usage Examples

**Web (`apps/web/src/utils/orpc.ts`)** - No changes needed, oRPC client automatically includes new routers.

**Native (`apps/native/`)**

```typescript
// Before
import { orpc } from "@/utils/orpc";
await orpc.preferences.update({ coachName: "Alex" });

// After (same API, different router)
await orpc.coach.update({ coachName: "Alex" });
await orpc.schedule.update({ workingHoursStart: "08:00" });
await orpc.goals.update({ goalsText: "My new goals" });
await orpc.preferences.update({ taskComplexity: "Ambitious" });
```

---

### Summary

| Phase | Files to Create/Modify       | Purpose                             |
| ----- | ---------------------------- | ----------------------------------- |
| 1     | 4 new schema files           | Define 4 domain-specific tables     |
| 2     | 2 update + 2 new query files | Database operations for each domain |
| 3     | 4 new + 1 updated router     | API endpoints per domain            |
| 4     | 2 migration files            | Schema + data migration             |
| 5     | Frontend updates             | Update oRPC usage                   |

Would you like me to switch to **Code mode** to implement this refactoring?
